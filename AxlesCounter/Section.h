#ifndef SECTION_H
#define SECTION_H
#include "Common.h"
#include "AxleSensor.h"

extern std::mutex cout_mutex; // семафор для вывода в выходной поток из разных потоков

// класс секция
// симуляция функции ДФБ для подсчета осей на секции и определения свободности
// при создании секции инициализируется счетчик осей находящихся на секции
// затем добавляются ссылки на датчики, ограничивающие секцию, и для каждого датчика указывается "входной" или "выходной"
// после добавления датчика производится расчет "обобщенного" счетчика ( алгебраическая сумма счетчиков всех датчиков, "входные" +, "выходные" - )
// функция AxleCount запускается из внешнего потока каждые 100 мс
// занятость определяется по занятости сенсорной системы или наличии осей на секции, переменная счетчика обратного отсчета инициализируется
// после освобождения сенсорной системы датчика и отсутствии осей на секции запускается обратный отсчет времени (в каждом цикле - 100 мс), устанавливается признак свободности секции
// про выдержку времени: фактически это защита от ложной свободности РЦ, но так как здесь подсчет осей то выдержка не нужна. 
// Интересовала сама возможность её реализовать.
// подсчет осей:
// производится расчет "обобщенного" счетчика ( алгебраическая сумма счетчиков всех датчиков, "входные" +, "выходные" - )
// берется разница между предыдущим и текущим значением "обобщенного" счетчика и прибавляется количество осей на секции до.
//
// "количество осей" = "сумма счетчиков текущего цикла" - "предыдущая сумма счетчиков" + "предыдущее количество осей"
// "сумма счетчиков" определяется путем сложения значений "входных" счетчиков и вычитания значений "выходных" счетчиков

class Section {
public:
	//имя секции, начальное кол-во осей на секции
	Section(const std::string& name, int initialAxles);

	~Section();

	// Добавление сенсора в секцию
	void addSensor(AxleSensor* sensor, bool add);

	// по состоянию счетчиков ДПК определить кол-во осей на секции
	void AxleCount();

	void print(int p = 2);

	int getAxles() const;

private:
	//инициализация после добавления в секцию датчика
	void InitBefore();

	std::string name;
	std::atomic<int> axlesCount; // количество осей на секции ( atomic нужно было для предыдущей версии )
	bool free;
	std::vector<std::pair<AxleSensor*, bool>> sensors;

	std::atomic<unsigned short> axlesBefore;
	std::atomic<unsigned short> sumCounterBefore;
	std::atomic<unsigned short> sumCounterCurrent;
	int countDown; // счетчик циклов задержки
	int cycles; // для задержки переключения на состояние свободна
};

#endif